[{"cursor":"Y3Vyc29yOnYyOpHOFFmSOA==","node":{"number":1,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFFqR3Q==","node":{"number":2,"reviewThreads":{"nodes":[{"comments":{"nodes":[{"body":"```suggestion\r\n    private final AtomicInteger resultCount = new AtomicInteger(0);\r\n```","author":{"login":"hcsp-bot"},"commit":{"oid":"fe598227f603325639cb05a952fdafc7641f4782"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}},{"body":"声明的时候可以直接声明0，就不用再getAndSet了","author":{"login":"hcsp-bot"},"commit":{"oid":"fe598227f603325639cb05a952fdafc7641f4782"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}},{"body":"那这个对象多次调用`processAllData`会产生问题吧","author":{"login":"BirdSnail"},"commit":{"oid":"fe598227f603325639cb05a952fdafc7641f4782"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}},{"body":"嗯，是的。要复用的话，也可以直接`resultCount.set(0);`。。。小问题。","author":{"login":"hcsp-bot"},"commit":{"oid":"fe598227f603325639cb05a952fdafc7641f4782"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}}]},"line":21,"originalLine":21,"originalStartLine":null,"startLine":null,"startDiffSide":null},{"comments":{"nodes":[{"body":"那直接在lambda表达式里try-catch不就行了：\r\n\r\n```\r\n                Thread thread = new Thread(() -> {\r\n                    for (Object o : dataGroup) {\r\n                        try {\r\n                           remoteService.processData(o);\r\n                        } catch(Exception e) {\r\n                           System.out.println(\"线程<\" + getName() + \">处理任务失败，catch：\" + e.getMessage());\r\n                        }   \r\n                        resultCount.incrementAndGet();\r\n                    }\r\n                });\r\n```\r\n\r\n当然在这里`thread.setUncaughtExceptionHandler`是没什么问题的，如果线程会在线程池里被复用的话，这个UncaughtExceptionHandler就会有问题了。","author":{"login":"hcsp-bot"},"commit":{"oid":"fe598227f603325639cb05a952fdafc7641f4782"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}}]},"line":49,"originalLine":49,"originalStartLine":null,"startLine":null,"startDiffSide":null}]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFFsndQ==","node":{"number":3,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFF6xnA==","node":{"number":4,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFF9DAA==","node":{"number":5,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFF_mcg==","node":{"number":6,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFF_oow==","node":{"number":7,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFGGvTA==","node":{"number":9,"reviewThreads":{"nodes":[{"comments":{"nodes":[{"body":"如果你学了JMM和volatile那一节，你就应该知道，这里需要使用同步，或者`volatile`，否则，它可能不会被其他线程看到。虽然现在没出问题，但是应该加volatile。","author":{"login":"hcsp-bot"},"commit":{"oid":"3213f172fdf701d65482e0df863ce4cfd885dc03"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}}]},"line":37,"originalLine":37,"originalStartLine":null,"startLine":null,"startDiffSide":null}]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFGUOtA==","node":{"number":10,"reviewThreads":{"nodes":[{"comments":{"nodes":[{"body":"根据Java线程模型，这里使用boolean实际上是有隐患的（虽然现在好像没问题，但并不代表这样是完全正确的）。要保证可见性，最简单的办法是volatile.","author":{"login":"hcsp-bot"},"commit":{"oid":"e1d4fb57722a209ba503a7dffbe57d4ab2933268"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}}]},"line":39,"originalLine":39,"originalStartLine":null,"startLine":null,"startDiffSide":null}]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFGXqVQ==","node":{"number":11,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFGsaYg==","node":{"number":12,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFIz1YQ==","node":{"number":13,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFJFSmw==","node":{"number":14,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFQyn8A==","node":{"number":15,"reviewThreads":{"nodes":[{"comments":{"nodes":[{"body":"你似乎没用到threadNumber个线程，只用到了一个线程啊。。","author":{"login":"hcsp-bot"},"commit":{"oid":"fec0d1cd214c4964d7d82cc78f72e7662efb2ec0"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}}]},"line":28,"originalLine":28,"originalStartLine":null,"startLine":null,"startDiffSide":null}]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFThJ-A==","node":{"number":16,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFURZJg==","node":{"number":17,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFURmaw==","node":{"number":18,"reviewThreads":{"nodes":[{"comments":{"nodes":[{"body":"你这样改变了全局的一个状态，在这个方法结束后，你将这个对全局状态的修改复原了么？\r\n\r\n虽然能通过测试，但是这是非常不好的实践：一个方法的调用会修改全局的某种状态，那并发情况下会不会有问题？例如，两个线程同时调用这个方法，二者都`setDefaultUncaughtExceptionHandler`，但是只会有一个生效（后调用的那么）。","author":{"login":"hcsp-bot"},"commit":{"oid":"33cf321375965102075213b05e3fb4b68442fcdf"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}}]},"line":32,"originalLine":32,"originalStartLine":null,"startLine":null,"startDiffSide":null}]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFU9t4w==","node":{"number":19,"reviewThreads":{"nodes":[{"comments":{"nodes":[{"body":"虽然能通过测试，但是这种使用成员变量的方式是非常不妥的，因为这使得这个方法没有办法被多个线程同时访问（因为两个线程同时调用这个方法会互相干扰）。","author":{"login":"hcsp-bot"},"commit":{"oid":"2e5e2e4497e024040bee249743b18ef7445d4430"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}}]},"line":49,"originalLine":49,"originalStartLine":null,"startLine":null,"startDiffSide":null}]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFWkvSA==","node":{"number":20,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFWohYw==","node":{"number":21,"reviewThreads":{"nodes":[{"comments":{"nodes":[{"body":"说实话，用实例变量这种方式并不好，想象一下，你调用了一个方法，这个方法改变了对象的状态，使得后续方法都没有办法正常调用，这是对的么？","author":{"login":"hcsp-bot"},"commit":{"oid":"dfdec645e3ee1fff91914c3336c5d194742beb00"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}},{"body":"更新了 用局部变量 https://github.com/hcsp/multithread-exception/pull/22","author":{"login":"JayChenFE"},"commit":{"oid":"dfdec645e3ee1fff91914c3336c5d194742beb00"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}}]},"line":14,"originalLine":14,"originalStartLine":null,"startLine":null,"startDiffSide":null}]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFYCjXw==","node":{"number":22,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFgld9g==","node":{"number":23,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFhwe4w==","node":{"number":24,"reviewThreads":{"nodes":[{"comments":{"nodes":[{"body":"所以为啥不用一个局部变量，而要用一个成员变量。。。你这样不就把这个方法变成一次性的了。。。只能用一次，因为成员变量的状态被被改变了。","author":{"login":"hcsp-bot"},"commit":{"oid":"59f384bd6064bdf6e14a4a13dcca14082f700577"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}},{"body":"哦哦，只想着用volatile了。局部变量的话就只能用AtomicBoolean了。Thanks for your review.","author":{"login":"Jay-Zou"},"commit":{"oid":"59f384bd6064bdf6e14a4a13dcca14082f700577"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}}]},"line":13,"originalLine":13,"originalStartLine":null,"startLine":null,"startDiffSide":null}]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFlzCcA==","node":{"number":25,"reviewThreads":{"nodes":[{"comments":{"nodes":[{"body":"两个问题：\r\n\r\n- 跨线程的修改要考虑可见性，现在没问题不代表以后一直没问题。如果没有同步的话，应该是`volatile`。\r\n- 使用field存储这个标识位有两个问题：\r\n  - 这个方法变成了“一次性的”，调用完之后就不能再用了，因为这个field的状态被改变了。\r\n  - 不支持并发调用。\r\n\r\n所以严重不建议使用field来存储这样的值。","author":{"login":"hcsp-bot"},"commit":{"oid":"ee2f666e80283b3c429cae6bcec68e6b435e6cd4"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}}]},"line":13,"originalLine":13,"originalStartLine":null,"startLine":null,"startDiffSide":null}]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFmTjKw==","node":{"number":26,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFziWoQ==","node":{"number":27,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFzo8jA==","node":{"number":28,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOFz3CiA==","node":{"number":29,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOF11TGg==","node":{"number":30,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOF11UeA==","node":{"number":31,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOF6lr1A==","node":{"number":32,"reviewThreads":{"nodes":[{"comments":{"nodes":[{"body":"请养成写完代码按一下格式化快捷键将代码格式化的习惯","author":{"login":"hcsp-bot"},"commit":{"oid":"8577b3e1bbfc37e3d6de58806fbb4f73c3d6de4a"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}}]},"line":36,"originalLine":36,"originalStartLine":null,"startLine":null,"startDiffSide":null},{"comments":{"nodes":[{"body":"这个flag使得方法不能被调用第二次，因为这个field的状态已经被改变了。应该使用局部变量。","author":{"login":"hcsp-bot"},"commit":{"oid":"8577b3e1bbfc37e3d6de58806fbb4f73c3d6de4a"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}}]},"line":14,"originalLine":14,"originalStartLine":null,"startLine":null,"startDiffSide":null}]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOF8nLmw==","node":{"number":33,"reviewThreads":{"nodes":[{"comments":{"nodes":[{"body":"全局的共享变量使得这个方法变成了一次性的，调用一次之后就不能再用，同时也不能并发调用。最好使用一个局部变量。","author":{"login":"hcsp-bot"},"commit":{"oid":"e3481e1a3d27ee23cac45dfb7306782cf28bc860"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}}]},"line":13,"originalLine":13,"originalStartLine":null,"startLine":null,"startDiffSide":null}]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOF9GwBQ==","node":{"number":34,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOF9uz7g==","node":{"number":35,"reviewThreads":{"nodes":[{"comments":{"nodes":[{"body":"这个flag会使得这个方法只能被调用一次，一旦它的状态改变了，就没法再次使用了。同时，也没办法并发使用。","author":{"login":"hcsp-bot"},"commit":{"oid":"841b4beef66b09d9b04e294323efcb596152df00"},"pullRequest":{"files":{"nodes":[{"path":"src/main/java/com/github/hcsp/MultiThreadServiceDataProcessor.java"}]}}}]},"line":14,"originalLine":14,"originalStartLine":null,"startLine":null,"startDiffSide":null}]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOGAREdA==","node":{"number":36,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOGBkYRg==","node":{"number":37,"reviewThreads":{"nodes":[]},"headRepository":null}},{"cursor":"Y3Vyc29yOnYyOpHOGIDhXw==","node":{"number":38,"reviewThreads":{"nodes":[]},"headRepository":null}}]